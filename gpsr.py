# -*- coding: utf-8 -*-
"""GPSR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1P-FFHwLi8ftuqyMq0KmeSkS4NvFkcDwh
"""

import random
import math
import matplotlib.pyplot as plt

# Define the Node class to represent each node in the network
class Node:
    def __init__(self, x, y, node_id):
        self.x = x
        self.y = y
        self.node_id = node_id

    def distance(self, other_node):
        """ Calculate Euclidean distance between two nodes """
        return math.sqrt((self.x - other_node.x) ** 2 + (self.y - other_node.y) ** 2)

    def __repr__(self):
        return f"Node({self.node_id}, {self.x}, {self.y})"

# Define the GPSR Routing Algorithm
class GPSR:
    def __init__(self, nodes, sink_node):
        self.nodes = nodes
        self.sink_node = sink_node

    def greedy_forwarding(self, source_node):
        """ Greedy forwarding step of GPSR: Forward towards the sink node. """
        closest_node = None
        min_dist = float('inf')

        for node in self.nodes:
            if node != source_node:
                dist = source_node.distance(node)
                if dist < min_dist and node != source_node:  # Avoid the same node
                    closest_node = node
                    min_dist = dist
        return closest_node

    def perimeter_routing(self, source_node):
        """ Perimeter routing to handle cases when greedy forwarding cannot proceed. """
        # Simple implementation: assume we have some perimeter routing functionality here.
        return None  # Perimeter routing logic can be added here.

    def route(self, source_node):
        """ Main routing function of GPSR. """
        path = [source_node]
        current_node = source_node

        while current_node != self.sink_node:
            next_node = self.greedy_forwarding(current_node)

            if next_node is None or next_node == current_node:
                # If no next node found or stuck, use perimeter routing
                next_node = self.perimeter_routing(current_node)

            if next_node is None:
                print("No route found.")
                return path

            path.append(next_node)
            current_node = next_node

        return path

# Generate random nodes
def generate_random_nodes(num_nodes, width, height):
    nodes = []
    for i in range(num_nodes):
        x = random.uniform(0, width)
        y = random.uniform(0, height)
        nodes.append(Node(x, y, i))
    return nodes

# Plot the network and route
def plot_network(nodes, path=None):
    plt.figure(figsize=(10, 10))
    for node in nodes:
        plt.scatter(node.x, node.y, c='blue')
        plt.text(node.x + 0.5, node.y + 0.5, str(node.node_id), fontsize=12)

    if path:
        path_x = [node.x for node in path]
        path_y = [node.y for node in path]
        plt.plot(path_x, path_y, c='red', marker='o')

    plt.xlabel("X Coordinate")
    plt.ylabel("Y Coordinate")
    plt.title("GPSR Routing Algorithm")
    plt.grid(True)
    plt.show()

# Main function to execute GPSR
if __name__ == "__main__":
    # Parameters
    num_nodes = 10
    width = 100
    height = 100

    # Generate random nodes and set the sink node
    nodes = generate_random_nodes(num_nodes, width, height)
    sink_node = random.choice(nodes)

    # Define the source node
    source_node = random.choice(nodes)

    print(f"Source Node: {source_node}")
    print(f"Sink Node: {sink_node}")

    # Create GPSR instance and calculate the route
    gpsr = GPSR(nodes, sink_node)
    route = gpsr.route(source_node)

    print("Route:")
    for node in route:
        print(node)

    # Plot the network and the path taken
    plot_network(nodes, path=route)